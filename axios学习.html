<!DOCTYPE html>
<html>
<head>
<title>axios学习.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="axios">Axios</h1>
<h2 id="1-%E7%89%B9%E6%80%A7">1. 特性</h2>
<ul>
<li>从浏览器中创建 XMLHttpRequests</li>
<li>从 node.js 创建 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 XSRF</li>
</ul>
<hr>
<h2 id="2-%E5%AE%89%E8%A3%85npm">2. 安装（npm）</h2>
<h2 id="npm-install-axios"><code>npm install axios</code></h2>
<h2 id="3-%E6%89%A7%E8%A1%8Cget%E8%AF%B7%E6%B1%82">3. 执行get请求</h2>
<pre class="hljs"><code><div>&gt;axios.get(<span class="hljs-string">'/user?ID=12345'</span>)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
    <span class="hljs-built_in">console</span>.log(response);
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-built_in">console</span>.log(error);
  });
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// 上面的请求也可以这样做</span>
axios.get(<span class="hljs-string">'/user'</span>, {
    <span class="hljs-attr">params</span>: {
      <span class="hljs-attr">ID</span>: <span class="hljs-number">12345</span>
    }
  })
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
    <span class="hljs-built_in">console</span>.log(response);
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-built_in">console</span>.log(error);
  });
</div></code></pre>
<hr>
<h2 id="4-%E6%89%A7%E8%A1%8Cpost%E8%AF%B7%E6%B1%82">4. 执行post请求</h2>
<pre class="hljs"><code><div>axios.post(<span class="hljs-string">'/user'</span>, {
  <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Fred'</span>,
  <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Flintstone'</span>
})
.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
  <span class="hljs-built_in">console</span>.log(response);
})
.catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
  <span class="hljs-built_in">console</span>.log(error);
});
</div></code></pre>
<hr>
<h2 id="5-axios-api">5. axios API</h2>
<p>可以通过向 axios 传递相关配置来创建请求</p>
<h3 id="1-axiosconfig"><em>1. axios(config)</em></h3>
<pre class="hljs"><code><div><span class="hljs-comment">// 发送 POST 请求</span>
axios({
  <span class="hljs-attr">method</span>: <span class="hljs-string">'post'</span>,
  <span class="hljs-attr">url</span>: <span class="hljs-string">'/user/12345'</span>,
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Fred'</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Flintstone'</span>
  }
});
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// 获取远端图片</span>
axios({
  <span class="hljs-attr">method</span>:<span class="hljs-string">'get'</span>,
  <span class="hljs-attr">url</span>:<span class="hljs-string">'http://bit.ly/2mTM3nY'</span>,
  <span class="hljs-attr">responseType</span>:<span class="hljs-string">'stream'</span>
})
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>{
  response.data.pipe(fs.createWriteStream(<span class="hljs-string">'ada_lovelace.jpg'</span>))
});
</div></code></pre>
<h3 id="2-axiosurl-config%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><em>2. axios(url[, config])(默认方法)</em></h3>
<p><code>axios('/user/12345');</code></p>
<h3 id="3-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%AB%E5%90%8D"><em>3. 请求方法的别名</em></h3>
<ul>
<li>axios.request(config)</li>
<li>axios.get(url[, config])</li>
<li>axios.delete(url[, config])</li>
<li>axios.head(url[, config])</li>
<li>axios.options(url[, config])</li>
<li>axios.post(url[, data[, config]])</li>
<li>axios.put(url[, data[, config]])</li>
<li>axios.patch(url[, data[, config]])
<code>url、method、data 这些属性都不必在配置中指定。</code></li>
</ul>
<h3 id="4-%E5%B9%B6%E5%8F%91"><em>4. 并发</em></h3>
<p>处理并发请求的助手函数</p>
<ul>
<li>axios.all(iterable)</li>
<li>axios.spread(callback)</li>
</ul>
<h3 id="5-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B"><em>5. 创建实例</em></h3>
<ul>
<li>axios.create([config])
可以使用自定义配置新建一个 axios 实例</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> instance = axios.create({
  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://some-domain.com/api/'</span>,
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span>,
  <span class="hljs-attr">headers</span>: {<span class="hljs-string">'X-Custom-Header'</span>: <span class="hljs-string">'foobar'</span>}
});
</div></code></pre>
<h3 id="6-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><em>6. 实例方法</em></h3>
<p>以下是可用的实例方法。指定的配置将与实例的配置合并。</p>
<ul>
<li>axios#request(config)</li>
<li>axios#get(url[, config])</li>
<li>axios#delete(url[, config])</li>
<li>axios#head(url[, config])</li>
<li>axios#options(url[, config])</li>
<li>axios#post(url[, data[, config]])</li>
<li>axios#put(url[, data[, config]])</li>
<li>axios#patch(url[, data[, config]])</li>
</ul>
<h3 id="7-%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE"><em>7. 请求配置</em></h3>
<p>这些是创建请求时可以用的配置选项。只有 <code>url</code>是必需的。如果没有<code>指定 method</code>，请求将默认使用 <code>get 方法</code></p>
<pre class="hljs"><code><div>{
   <span class="hljs-comment">// `url` 是用于请求的服务器 URL</span>
  <span class="hljs-attr">url</span>: <span class="hljs-string">'/user'</span>,

  <span class="hljs-comment">// `method` 是创建请求时使用的方法</span>
  <span class="hljs-attr">method</span>: <span class="hljs-string">'get'</span>, <span class="hljs-comment">// default</span>

  <span class="hljs-comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span>
  <span class="hljs-comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span>
  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://some-domain.com/api/'</span>,

  <span class="hljs-comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span>
  <span class="hljs-comment">// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法</span>
  <span class="hljs-comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span>
  <span class="hljs-attr">transformRequest</span>: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, headers</span>) </span>{
    <span class="hljs-comment">// 对 data 进行任意转换处理</span>
    <span class="hljs-keyword">return</span> data;
  }],

  <span class="hljs-comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span>
  <span class="hljs-attr">transformResponse</span>: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>{
    <span class="hljs-comment">// 对 data 进行任意转换处理</span>
    <span class="hljs-keyword">return</span> data;
  }],

  <span class="hljs-comment">// `headers` 是即将被发送的自定义请求头</span>
  <span class="hljs-attr">headers</span>: {<span class="hljs-string">'X-Requested-With'</span>: <span class="hljs-string">'XMLHttpRequest'</span>},

  <span class="hljs-comment">// `params` 是即将与请求一起发送的 URL 参数</span>
  <span class="hljs-comment">// 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span>
  <span class="hljs-attr">params</span>: {
    <span class="hljs-attr">ID</span>: <span class="hljs-number">12345</span>
  },

   <span class="hljs-comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span>
  <span class="hljs-comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span>
  <span class="hljs-attr">paramsSerializer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">params</span>) </span>{
    <span class="hljs-keyword">return</span> Qs.stringify(params, {<span class="hljs-attr">arrayFormat</span>: <span class="hljs-string">'brackets'</span>})
  },

  <span class="hljs-comment">// `data` 是作为请求主体被发送的数据</span>
  <span class="hljs-comment">// 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH'</span>
  <span class="hljs-comment">// 在没有设置 `transformRequest` 时，必须是以下类型之一：</span>
  <span class="hljs-comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span>
  <span class="hljs-comment">// - 浏览器专属：FormData, File, Blob</span>
  <span class="hljs-comment">// - Node 专属： Stream</span>
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Fred'</span>
  },

  <span class="hljs-comment">// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span>
  <span class="hljs-comment">// 如果请求话费了超过 `timeout` 的时间，请求将被中断</span>
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span>,

   <span class="hljs-comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span>
  <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// default</span>

  <span class="hljs-comment">// `adapter` 允许自定义处理请求，以使测试更轻松</span>
  <span class="hljs-comment">// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).</span>
  <span class="hljs-attr">adapter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>{
    <span class="hljs-comment">/* ... */</span>
  },

 <span class="hljs-comment">// `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span>
  <span class="hljs-comment">// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers`</span>
  <span class="hljs-comment">// 设置的自定义 `Authorization`头</span>
  <span class="hljs-attr">auth</span>: {
    <span class="hljs-attr">username</span>: <span class="hljs-string">'janedoe'</span>,
    <span class="hljs-attr">password</span>: <span class="hljs-string">'s00pers3cret'</span>
  },

   <span class="hljs-comment">// `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'</span>
  <span class="hljs-attr">responseType</span>: <span class="hljs-string">'json'</span>, <span class="hljs-comment">// default</span>

  <span class="hljs-comment">// `responseEncoding` indicates encoding to use for decoding responses</span>
  <span class="hljs-comment">// Note: Ignored for `responseType` of 'stream' or client-side requests</span>
  <span class="hljs-attr">responseEncoding</span>: <span class="hljs-string">'utf8'</span>, <span class="hljs-comment">// default</span>

   <span class="hljs-comment">// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span>
  <span class="hljs-attr">xsrfCookieName</span>: <span class="hljs-string">'XSRF-TOKEN'</span>, <span class="hljs-comment">// default</span>

  <span class="hljs-comment">// `xsrfHeaderName` is the name of the http header that carries the xsrf token value</span>
  <span class="hljs-attr">xsrfHeaderName</span>: <span class="hljs-string">'X-XSRF-TOKEN'</span>, <span class="hljs-comment">// default</span>

   <span class="hljs-comment">// `onUploadProgress` 允许为上传处理进度事件</span>
  <span class="hljs-attr">onUploadProgress</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) </span>{
    <span class="hljs-comment">// Do whatever you want with the native progress event</span>
  },

  <span class="hljs-comment">// `onDownloadProgress` 允许为下载处理进度事件</span>
  <span class="hljs-attr">onDownloadProgress</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">progressEvent</span>) </span>{
    <span class="hljs-comment">// 对原生进度事件的处理</span>
  },

   <span class="hljs-comment">// `maxContentLength` 定义允许的响应内容的最大尺寸</span>
  <span class="hljs-attr">maxContentLength</span>: <span class="hljs-number">2000</span>,

  <span class="hljs-comment">// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve </span>
  <span class="hljs-comment">//或 reject  promise 。如果 `validateStatus` 返回 `true` </span>
  <span class="hljs-comment">//(或者设置为 `null` 或 `undefined`)，promise 将被 resolve; </span>
  <span class="hljs-comment">//否则，promise 将被 reject</span>
  <span class="hljs-attr">validateStatus</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) </span>{
    <span class="hljs-keyword">return</span> status &gt;= <span class="hljs-number">200</span> &amp;&amp; status &lt; <span class="hljs-number">300</span>; <span class="hljs-comment">// default</span>
  },

  <span class="hljs-comment">// `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span>
  <span class="hljs-comment">// 如果设置为0，将不会 follow 任何重定向</span>
  <span class="hljs-attr">maxRedirects</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">// default</span>

  <span class="hljs-comment">// `socketPath` defines a UNIX Socket to be used in node.js.</span>
  <span class="hljs-comment">// e.g. '/var/run/docker.sock' to send requests to the docker daemon.</span>
  <span class="hljs-comment">// Only either `socketPath` or `proxy` can be specified.</span>
  <span class="hljs-comment">// If both are specified, `socketPath` is used.</span>
  <span class="hljs-attr">socketPath</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// default</span>

  <span class="hljs-comment">// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span>
  <span class="hljs-comment">// `keepAlive` 默认没有启用</span>
  <span class="hljs-attr">httpAgent</span>: <span class="hljs-keyword">new</span> http.Agent({ <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> }),
  <span class="hljs-attr">httpsAgent</span>: <span class="hljs-keyword">new</span> https.Agent({ <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> }),

  <span class="hljs-comment">// 'proxy' 定义代理服务器的主机名称和端口</span>
  <span class="hljs-comment">// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span>
  <span class="hljs-comment">// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span>
  <span class="hljs-attr">proxy</span>: {
    <span class="hljs-attr">host</span>: <span class="hljs-string">'127.0.0.1'</span>,
    <span class="hljs-attr">port</span>: <span class="hljs-number">9000</span>,
    <span class="hljs-attr">auth</span>: {
      <span class="hljs-attr">username</span>: <span class="hljs-string">'mikeymike'</span>,
      <span class="hljs-attr">password</span>: <span class="hljs-string">'rapunz3l'</span>
    }
  },

  <span class="hljs-comment">// `cancelToken` 指定用于取消请求的 cancel token</span>
  <span class="hljs-comment">// （查看后面的 Cancellation 这节了解更多）</span>
  <span class="hljs-attr">cancelToken</span>: <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cancel</span>) </span>{
  })
}
</div></code></pre>
<h3 id="8-%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%84"><em>8. 响应结构</em></h3>
<p>某个请求的响应包含以下信息</p>
<pre class="hljs"><code><div>{
  <span class="hljs-comment">// `data` 由服务器提供的响应</span>
  <span class="hljs-attr">data</span>: {},

  <span class="hljs-comment">// `status` 来自服务器响应的 HTTP 状态码</span>
  <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,

  <span class="hljs-comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span>
  <span class="hljs-attr">statusText</span>: <span class="hljs-string">'OK'</span>,

  <span class="hljs-comment">// `headers` 服务器响应的头</span>
  <span class="hljs-attr">headers</span>: {},

   <span class="hljs-comment">// `config` 是为请求提供的配置信息</span>
  <span class="hljs-attr">config</span>: {},
 <span class="hljs-comment">// 'request'</span>
  <span class="hljs-comment">// `request` is the request that generated this response</span>
  <span class="hljs-comment">// It is the last ClientRequest instance in node.js (in redirects)</span>
  <span class="hljs-comment">// and an XMLHttpRequest instance the browser</span>
  <span class="hljs-attr">request</span>: {}
}
</div></code></pre>
<p>使用 then 时，你将接收下面这样的响应 :</p>
<pre class="hljs"><code><div>axios.get(<span class="hljs-string">'/user/12345'</span>)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>{
    <span class="hljs-built_in">console</span>.log(response.data);
    <span class="hljs-built_in">console</span>.log(response.status);
    <span class="hljs-built_in">console</span>.log(response.statusText);
    <span class="hljs-built_in">console</span>.log(response.headers);
    <span class="hljs-built_in">console</span>.log(response.config);
  });
</div></code></pre>
<p>在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用。</p>
<h3 id="9-%E9%85%8D%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BC"><em>9. 配置默认值</em></h3>
<p>你可以指定将被用在各个请求的配置默认值</p>
<ul>
<li>全局axios默认值</li>
</ul>
<pre class="hljs"><code><div>axios.defaults.baseURL = <span class="hljs-string">'https://api.example.com'</span>;
axios.defaults.headers.common[<span class="hljs-string">'Authorization'</span>] = AUTH_TOKEN;
axios.defaults.headers.post[<span class="hljs-string">'Content-Type'</span>] = <span class="hljs-string">'application/x-www-form-urlencoded'</span>;
</div></code></pre>
<ul>
<li>自定义实例默认值</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// Set config defaults when creating the instance</span>
<span class="hljs-keyword">const</span> instance = axios.create({
  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">'https://api.example.com'</span>
});

<span class="hljs-comment">// Alter defaults after instance has been created</span>
instance.defaults.headers.common[<span class="hljs-string">'Authorization'</span>] = AUTH_TOKEN;

</div></code></pre>
<ul>
<li>配置生效的优先顺序</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 使用由库提供的配置的默认值来创建实例</span>
<span class="hljs-comment">// 此时超时配置的默认值是 `0`</span>
<span class="hljs-keyword">var</span> instance = axios.create();

<span class="hljs-comment">// 覆写库的超时默认值</span>
<span class="hljs-comment">// 现在，在超时前，所有请求都会等待 2.5 秒</span>
instance.defaults.timeout = <span class="hljs-number">2500</span>;

<span class="hljs-comment">// 为已知需要花费很长时间的请求覆写超时设置</span>
instance.get(<span class="hljs-string">'/longRequest'</span>, {
  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>
});
</div></code></pre>
<h3 id="10-%E6%8B%A6%E6%88%AA%E5%99%A8"><em>10. 拦截器</em></h3>
<p>在请求或响应被 then 或 catch 处理前拦截它们。</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 添加请求拦截器</span>
axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) </span>{
    <span class="hljs-comment">// 在发送请求之前做些什么</span>
    <span class="hljs-keyword">return</span> config;
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-comment">// 对请求错误做些什么</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);
  });

<span class="hljs-comment">// 添加响应拦截器</span>
axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
    <span class="hljs-comment">// 对响应数据做点什么</span>
    <span class="hljs-keyword">return</span> response;
  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-comment">// 对响应错误做点什么</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);
  });
</div></code></pre>
<p>如果你想在稍后移除拦截器，可以这样：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> myInterceptor = axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{<span class="hljs-comment">/*...*/</span>});
axios.interceptors.request.eject(myInterceptor);
</div></code></pre>
<p>可以为自定义 axios 实例添加拦截器</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> instance = axios.create();
instance.interceptors.request.use(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{<span class="hljs-comment">/*...*/</span>});
</div></code></pre>
<h3 id="11-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><em>11. 错误处理</em></h3>
<pre class="hljs"><code><div>axios.get(<span class="hljs-string">'/user/12345'</span>)
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>{
    <span class="hljs-keyword">if</span> (error.response) {
      <span class="hljs-comment">// The request was made and the server responded with a status code</span>
      <span class="hljs-comment">// that falls out of the range of 2xx</span>
      <span class="hljs-built_in">console</span>.log(error.response.data);
      <span class="hljs-built_in">console</span>.log(error.response.status);
      <span class="hljs-built_in">console</span>.log(error.response.headers);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error.request) {
      <span class="hljs-comment">// The request was made but no response was received</span>
      <span class="hljs-comment">// `error.request` is an instance of XMLHttpRequest in the browser and an instance of</span>
      <span class="hljs-comment">// http.ClientRequest in node.js</span>
      <span class="hljs-built_in">console</span>.log(error.request);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Something happened in setting up the request that triggered an Error</span>
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Error'</span>, error.message);
    }
    <span class="hljs-built_in">console</span>.log(error.config);
  });
</div></code></pre>
<p>Y可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。</p>
<pre class="hljs"><code><div>axios.get(<span class="hljs-string">'/user/12345'</span>, {
  <span class="hljs-attr">validateStatus</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">status</span>) </span>{
    <span class="hljs-keyword">return</span> status &lt; <span class="hljs-number">500</span>; <span class="hljs-comment">// Reject only if the status code is greater than or equal to 500</span>
  }
})
</div></code></pre>
<h3 id="12-%E5%8F%96%E6%B6%88"><em>12. 取消</em></h3>
<blockquote>
<p>Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。
可以使用 CancelToken.source 工厂方法创建 cancel token，像这样：</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> CancelToken = axios.CancelToken;
<span class="hljs-keyword">const</span> source = CancelToken.source();

axios.get(<span class="hljs-string">'/user/12345'</span>, {
  <span class="hljs-attr">cancelToken</span>: source.token
}).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thrown</span>) </span>{
  <span class="hljs-keyword">if</span> (axios.isCancel(thrown)) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Request canceled'</span>, thrown.message);
  } <span class="hljs-keyword">else</span> {
     <span class="hljs-comment">// 处理错误</span>
  }
});

axios.post(<span class="hljs-string">'/user/12345'</span>, {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'new name'</span>
}, {
  <span class="hljs-attr">cancelToken</span>: source.token
})

<span class="hljs-comment">// 取消请求（message 参数是可选的）</span>
source.cancel(<span class="hljs-string">'Operation canceled by the user.'</span>);

</div></code></pre>
<p>还可以通过传递一个 executor 函数到 <code>CancelToken</code> 的构造函数来创建 cancel token：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> CancelToken = axios.CancelToken;
<span class="hljs-keyword">let</span> cancel;

axios.get(<span class="hljs-string">'/user/12345'</span>, {
  <span class="hljs-attr">cancelToken</span>: <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executor</span>(<span class="hljs-params">c</span>) </span>{
    <span class="hljs-comment">// executor 函数接收一个 cancel 函数作为参数</span>
    cancel = c;
  })
});

<span class="hljs-comment">// cancel the request</span>
cancel();
</div></code></pre>
<blockquote>
<p>注意: 可以使用同一个 cancel token 取消多个请求</p>
</blockquote>
<hr>
<h2 id="6-%E4%BD%BF%E7%94%A8applicationx-www-form-urlencoded-format">6. 使用application/x-www-form-urlencoded format</h2>
<p>默认情况下，axios将JavaScript对象序列化为JSON。
要以application / x-www-form-urlencoded格式发送数据，
您可以使用以下选项之一。</p>
<p>-Node.js
在node.js中，您可以使用querystring模块，如下所示</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">'querystring'</span>);
axios.post(<span class="hljs-string">'http://something.com/'</span>, querystring.stringify({ <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> }));

</div></code></pre>
<p>您也可以使用qs库</p>
<h3 id="1-%E5%AE%89%E8%A3%85qs%E5%BA%93"><em>1. 安装qs库</em></h3>
<p><code>npm install qs</code></p>
<h3 id="2-%E4%BD%BF%E7%94%A8-qs-%E7%9A%84-stringify-%E6%96%B9%E6%B3%95%E5%B0%86-javascript-%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><em>2. 使用 qs 的 stringify 方法将 JavaScript 对象转化为查询字符串</em></h3>
<p>下面是在 axios POST 请求中使用 qs 的一个示例：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">'axios'</span>);
<span class="hljs-keyword">const</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'qs'</span>);

<span class="hljs-keyword">let</span> data = {
  <span class="hljs-string">'key1'</span>: <span class="hljs-string">'value1'</span>,
  <span class="hljs-string">'key2'</span>: <span class="hljs-string">'value2'</span>
};

axios({
  <span class="hljs-attr">method</span>: <span class="hljs-string">'post'</span>,
  <span class="hljs-attr">url</span>: <span class="hljs-string">'http://example.com'</span>,
  <span class="hljs-attr">data</span>: qs.stringify(data),
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">'content-type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded;charset=utf-8'</span>
  }
})
.then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(response);
})
.catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(error);
});

</div></code></pre>
<p>在请求不同的对象还有以下的形式</p>
<ul>
<li>嵌套对象</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'qs'</span>);

<span class="hljs-keyword">const</span> data = {
  <span class="hljs-attr">filter</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
  }
};

<span class="hljs-built_in">console</span>.log(qs.stringify(data)); <span class="hljs-comment">// 输出: 'filter[name]=John&amp;filter[age]=30'</span>

</div></code></pre>
<ul>
<li>数组</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'qs'</span>);

<span class="hljs-keyword">const</span> data = {
  <span class="hljs-attr">colors</span>: [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'green'</span>]
};

<span class="hljs-built_in">console</span>.log(qs.stringify(data)); <span class="hljs-comment">// 输出: 'colors[0]=red&amp;colors[1]=blue&amp;colors[2]=green'</span>

</div></code></pre>
<ul>
<li>以不同的格式序列化数组</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'qs'</span>);

<span class="hljs-keyword">const</span> data = {
  <span class="hljs-attr">colors</span>: [<span class="hljs-string">'red'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'green'</span>]
};

<span class="hljs-built_in">console</span>.log(qs.stringify(data, {<span class="hljs-attr">arrayFormat</span>: <span class="hljs-string">'brackets'</span>})); <span class="hljs-comment">// 输出: 'colors[]=red&amp;colors[]=blue&amp;colors[]=green'</span>

</div></code></pre>

</body>
</html>
